
// This file is automatically generated. Do not edit it directly.
import { createClient } from '@supabase/supabase-js';
import type { Database } from './types';

const SUPABASE_URL = "https://fxphpfvfcogalwtbishv.supabase.co";
const SUPABASE_PUBLISHABLE_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImZ4cGhwZnZmY29nYWx3dGJpc2h2Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDU0NTQyNDksImV4cCI6MjA2MTAzMDI0OX0.9sxvHMcbdX8n0VY_3sNF9qL7i5EN8FAMOHWy738reh0";

// Declare custom window property for TypeScript
declare global {
  interface Window {
    cafeDataLastRefreshed?: number;
    cafeDataRefreshCallbacks?: Array<() => void>;
    connectivityStatus?: 'online' | 'recovering' | 'offline';
  }
}

// Import the supabase client like this:
// import { supabase } from "@/integrations/supabase/client";

export const supabase = createClient<Database>(
  SUPABASE_URL, 
  SUPABASE_PUBLISHABLE_KEY,
  {
    auth: {
      autoRefreshToken: true,
      persistSession: true,
      detectSessionInUrl: true,
      storageKey: 'supabase-horeca-app-auth'
    },
    realtime: {
      params: {
        eventsPerSecond: 10
      }
    },
    db: {
      schema: 'public'
    },
    global: {
      fetch: (...args) => {
        // Use custom fetch with built-in timeout
        return Promise.race([
          fetch(...args),
          new Promise((_, reject) => 
            setTimeout(() => reject(new Error('Request timeout')), 15000)
          )
        ]) as Promise<Response>;
      }
    }
  }
);

// Initialize connectivity status
if (typeof window !== 'undefined') {
  window.connectivityStatus = navigator.onLine ? 'online' : 'offline';
  
  // Set up online/offline event listeners
  window.addEventListener('online', () => {
    console.log('Device is back online, attempting to reconnect...');
    window.connectivityStatus = 'recovering';
    
    // Update status after successful reconnection
    checkConnectivity().then(isConnected => {
      window.connectivityStatus = isConnected ? 'online' : 'offline';
      if (isConnected) {
        console.log('Successfully reconnected to Supabase');
        refreshCafeData();
      }
    });
  });
  
  window.addEventListener('offline', () => {
    console.log('Device went offline');
    window.connectivityStatus = 'offline';
  });
}

// Helper function to check connectivity to Supabase
async function checkConnectivity(): Promise<boolean> {
  try {
    // Simple health check query
    await supabase.from('cafes').select('count').limit(1).maybeSingle();
    return true;
  } catch (error) {
    console.error('Connectivity check failed:', error);
    return false;
  }
}

// Manual function to initialize database structure
const initializeDatabase = async () => {
  try {
    // Call the rls_helper function to set up the database structure
    const { data, error } = await supabase.functions.invoke('rls_helper');
    
    if (error) {
      console.error('Failed to initialize database:', error);
    } else {
      console.log('Database initialization completed successfully:', data);
    }
  } catch (error) {
    console.error('Error initializing database structure:', error);
  }
};

// Call database initialization on client load with retry logic
(async function initWithRetry(attempts = 0) {
  try {
    await initializeDatabase();
  } catch (err) {
    if (attempts < 3) {
      console.log(`Retrying database initialization (attempt ${attempts + 1})...`);
      setTimeout(() => initWithRetry(attempts + 1), 2000 * Math.pow(2, attempts));
    } else {
      console.error('Failed to initialize database after multiple attempts');
    }
  }
})();

// Enable realtime for tables specifically related to cafes
export const enableRealtimeForTables = async () => {
  try {
    console.log("[Realtime] Starting enableRealtimeForTables");
    // We use a single channel with multiple table subscriptions for efficiency
    const tables = ['cafes', 'cafe_surveys', 'brand_sales', 'users'];
    
    // Enable realtime for each table via edge function
    for (const table of tables) {
      try {
        // First try the rls_helper function
        const { data, error } = await supabase.functions.invoke('rls_helper');
        
        if (error) {
          console.error(`[Realtime] Error enabling realtime via edge function for ${table}:`, error);
          
          // Try direct call to enable-realtime function if rls_helper fails
          const { data: directData, error: directError } = await supabase.functions.invoke('enable-realtime', {
            body: { table_name: table }
          });
          
          if (directError) {
            console.error(`[Realtime] Direct call also failed for ${table}:`, directError);
          } else {
            console.log(`[Realtime] Successfully enabled realtime via direct call for ${table}`, directData);
          }
        } else {
          console.log(`[Realtime] Successfully enabled realtime via edge function for ${table}:`, data);
        }
      } catch (err) {
        console.error(`[Realtime] Failed to enable realtime for ${table}:`, err);
      }
    }
    
    // Create a more reliable monitoring channel
    const monitorChannel = supabase.channel('db-changes-monitor');
    
    // Add listeners for all tables
    tables.forEach(table => {
      // Listen for all changes (INSERT, UPDATE, DELETE)
      monitorChannel.on(
        'postgres_changes', 
        { 
          event: '*', 
          schema: 'public', 
          table 
        },
        (payload) => {
          console.log(`[Realtime] ${table} change detected:`, payload);
          
          // Notify via local storage for cross-tab communication
          localStorage.setItem('cafe_data_updated', String(new Date().getTime()));
          
          // Also dispatch a custom event for same-tab communication
          window.dispatchEvent(new CustomEvent('horeca_data_updated', {
            detail: { table, payload }
          }));
        }
      );
    });

    // Subscribe with retry logic
    const trySubscribe = async (attempt = 1, maxAttempts = 5) => {
      try {
        const status = monitorChannel.subscribe((status) => {
          console.log(`[Realtime] Subscription status: ${status}`);
        });
        console.log(`[Realtime] Monitor channel subscribed: ${status}`);
        return true;
      } catch (err) {
        console.error(`[Realtime] Subscription attempt ${attempt} failed:`, err);
        if (attempt < maxAttempts) {
          console.log(`[Realtime] Retrying in ${attempt * 2}s...`);
          await new Promise(resolve => setTimeout(resolve, attempt * 2000));
          return trySubscribe(attempt + 1, maxAttempts);
        }
        return false;
      }
    };
    
    await trySubscribe();
    console.log('[Realtime] Enabled for all database tables');
  } catch (error) {
    console.error('[Realtime] Error setting up realtime:', error);
  }
};

// Call the function when the client is initialized with retry logic
(async function enableRealtimeWithRetry(attempts = 0) {
  try {
    await enableRealtimeForTables();
  } catch (err) {
    if (attempts < 3) {
      console.log(`Retrying realtime setup (attempt ${attempts + 1})...`);
      setTimeout(() => enableRealtimeWithRetry(attempts + 1), 3000 * Math.pow(2, attempts));
    } else {
      console.error('Failed to enable realtime after multiple attempts');
    }
  }
})();

// Add a global callback registry for refresh events
if (typeof window !== 'undefined') {
  window.cafeDataRefreshCallbacks = window.cafeDataRefreshCallbacks || [];
}

// Register a refresh callback
export const registerRefreshCallback = (callback: () => void) => {
  if (typeof window !== 'undefined' && callback) {
    window.cafeDataRefreshCallbacks = window.cafeDataRefreshCallbacks || [];
    window.cafeDataRefreshCallbacks.push(callback);
    return () => {
      // Return unregister function
      if (window.cafeDataRefreshCallbacks) {
        window.cafeDataRefreshCallbacks = window.cafeDataRefreshCallbacks.filter(cb => cb !== callback);
      }
    };
  }
  return () => {}; // Empty unregister function
};

// Force a data refresh - event-based instead of direct function calls
export const refreshCafeData = () => {
  console.log('[refreshCafeData] Triggering data refresh through events');
  
  // Dispatch event for same-tab communication
  window.dispatchEvent(new CustomEvent('horeca_data_updated'));
  
  // Update localStorage for cross-tab communication
  localStorage.setItem('cafe_data_updated', String(new Date().getTime()));
  
  // Additional global flag to ensure all components can detect the refresh
  try {
    window.cafeDataLastRefreshed = Date.now();
  } catch (e) {
    console.warn("Could not set global refresh flag");
  }
  
  // Execute all registered callbacks
  if (window.cafeDataRefreshCallbacks) {
    window.cafeDataRefreshCallbacks.forEach(cb => {
      try {
        cb();
      } catch (e) {
        console.error('Error executing refresh callback:', e);
      }
    });
  }
};
