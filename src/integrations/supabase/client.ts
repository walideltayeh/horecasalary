
// This file is automatically generated. Do not edit it directly.
import { createClient } from '@supabase/supabase-js';
import type { Database } from './types';

const SUPABASE_URL = "https://fxphpfvfcogalwtbishv.supabase.co";
const SUPABASE_PUBLISHABLE_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImZ4cGhwZnZmY29nYWx3dGJpc2h2Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDU0NTQyNDksImV4cCI6MjA2MTAzMDI0OX0.9sxvHMcbdX8n0VY_3sNF9qL7i5EN8FAMOHWy738reh0";

// Declare custom window property for TypeScript
declare global {
  interface Window {
    cafeDataLastRefreshed?: number;
    cafeDataRefreshCallbacks?: Array<() => void>;
  }
}

// Import the supabase client like this:
// import { supabase } from "@/integrations/supabase/client";

export const supabase = createClient<Database>(
  SUPABASE_URL, 
  SUPABASE_PUBLISHABLE_KEY,
  {
    auth: {
      autoRefreshToken: true,
      persistSession: true,
      detectSessionInUrl: true,
      storageKey: 'supabase-horeca-app-auth'
    },
    realtime: {
      params: {
        eventsPerSecond: 10
      }
    },
    db: {
      schema: 'public'
    }
  }
);

// Manual function to initialize database structure
const initializeDatabase = async () => {
  try {
    // Call the rls_helper function to set up the database structure
    const { data, error } = await supabase.functions.invoke('rls_helper');
    
    if (error) {
      console.error('Failed to initialize database:', error);
    } else {
      console.log('Database initialization completed successfully:', data);
    }
  } catch (error) {
    console.error('Error initializing database structure:', error);
  }
};

// Call database initialization on client load
initializeDatabase();

// Enable realtime for tables specifically related to cafes
export const enableRealtimeForTables = async () => {
  try {
    console.log("[Realtime] Starting enableRealtimeForTables");
    // We use a single channel with multiple table subscriptions for efficiency
    const tables = ['cafes', 'cafe_surveys', 'brand_sales', 'users'];
    
    // Enable realtime for each table via edge function
    for (const table of tables) {
      try {
        // We'll use a more direct approach without the edge function since it's failing
        // Just set up the subscription without calling the enable-realtime function
        console.log(`[Realtime] Setting up subscription for ${table} without edge function`);
      } catch (err) {
        console.error(`[Realtime] Failed to enable realtime for ${table}:`, err);
      }
    }
    
    // Create a more reliable monitoring channel
    const monitorChannel = supabase.channel('db-changes-monitor');
    
    // Add listeners for all tables
    tables.forEach(table => {
      // Listen for all changes (INSERT, UPDATE, DELETE)
      monitorChannel.on(
        'postgres_changes', 
        { 
          event: '*', 
          schema: 'public', 
          table 
        },
        (payload) => {
          console.log(`[Realtime] ${table} change detected:`, payload);
          
          // Notify via local storage for cross-tab communication
          localStorage.setItem('cafe_data_updated', String(new Date().getTime()));
          
          // Also dispatch a custom event for same-tab communication
          window.dispatchEvent(new CustomEvent('horeca_data_updated', {
            detail: { table, payload }
          }));
        }
      );
    });

    // Subscribe with retry logic
    const trySubscribe = async (attempt = 1, maxAttempts = 5) => {
      try {
        const status = monitorChannel.subscribe((status) => {
          console.log(`[Realtime] Subscription status: ${status}`);
        });
        console.log(`[Realtime] Monitor channel subscribed: ${status}`);
        return true;
      } catch (err) {
        console.error(`[Realtime] Subscription attempt ${attempt} failed:`, err);
        if (attempt < maxAttempts) {
          console.log(`[Realtime] Retrying in ${attempt * 2}s...`);
          await new Promise(resolve => setTimeout(resolve, attempt * 2000));
          return trySubscribe(attempt + 1, maxAttempts);
        }
        return false;
      }
    };
    
    await trySubscribe();
    console.log('[Realtime] Enabled for all database tables');
  } catch (error) {
    console.error('[Realtime] Error setting up realtime:', error);
  }
};

// Call the function when the client is initialized
enableRealtimeForTables();

// Add a global callback registry for refresh events
if (typeof window !== 'undefined') {
  window.cafeDataRefreshCallbacks = window.cafeDataRefreshCallbacks || [];
}

// Register a refresh callback
export const registerRefreshCallback = (callback: () => void) => {
  if (typeof window !== 'undefined' && callback) {
    window.cafeDataRefreshCallbacks = window.cafeDataRefreshCallbacks || [];
    window.cafeDataRefreshCallbacks.push(callback);
    return () => {
      // Return unregister function
      if (window.cafeDataRefreshCallbacks) {
        window.cafeDataRefreshCallbacks = window.cafeDataRefreshCallbacks.filter(cb => cb !== callback);
      }
    };
  }
  return () => {}; // Empty unregister function
};

// Force a data refresh - event-based instead of direct function calls
export const refreshCafeData = async () => {
  console.log('[refreshCafeData] Triggering data refresh through events');
  
  // We'll skip the edge function call since it's failing
  try {
    // Instead of calling the edge function, let's just dispatch the events
    console.log("[refreshCafeData] Skipping edge function call and directly triggering refresh events");
    
    // Dispatch event for same-tab communication
    window.dispatchEvent(new CustomEvent('horeca_data_updated', {
      detail: { forceRefresh: true }
    }));
    
    // Update localStorage for cross-tab communication
    localStorage.setItem('cafe_data_updated', String(new Date().getTime()));
    
    // Call all registered callbacks
    if (window.cafeDataRefreshCallbacks && window.cafeDataRefreshCallbacks.length > 0) {
      console.log(`Calling ${window.cafeDataRefreshCallbacks.length} registered refresh callbacks`);
      window.cafeDataRefreshCallbacks.forEach(cb => {
        try {
          cb();
        } catch (err) {
          console.error("Error in refresh callback:", err);
        }
      });
    }
    
    // Additional global flag to ensure all components can detect the refresh
    try {
      window.cafeDataLastRefreshed = Date.now();
    } catch (e) {
      console.warn("Could not set global refresh flag");
    }
    
    return { success: true };
  } catch (err) {
    console.error("[refreshCafeData] Error refreshing data:", err);
    return { success: false, error: err };
  }
};

