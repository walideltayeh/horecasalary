
// This file is automatically generated. Do not edit it directly.
import { createClient } from '@supabase/supabase-js';
import type { Database } from './types';

const SUPABASE_URL = "https://fxphpfvfcogalwtbishv.supabase.co";
const SUPABASE_PUBLISHABLE_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImZ4cGhwZnZmY29nYWx3dGJpc2h2Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDU0NTQyNDksImV4cCI6MjA2MTAzMDI0OX0.9sxvHMcbdX8n0VY_3sNF9qL7i5EN8FAMOHWy738reh0";

// Import the supabase client like this:
// import { supabase } from "@/integrations/supabase/client";

export const supabase = createClient<Database>(
  SUPABASE_URL, 
  SUPABASE_PUBLISHABLE_KEY,
  {
    auth: {
      autoRefreshToken: true,
      persistSession: true,
      detectSessionInUrl: true,
      storageKey: 'supabase-horeca-app-auth'
    },
    realtime: {
      params: {
        eventsPerSecond: 10
      }
    },
    db: {
      schema: 'public'
    }
  }
);

// Manual function to initialize database structure
const initializeDatabase = async () => {
  try {
    // 1. Create function to execute SQL if it doesn't exist
    await supabase.rpc('execute_sql', {
      sql: `
      CREATE OR REPLACE FUNCTION public.execute_sql(sql text) RETURNS jsonb
      LANGUAGE plpgsql
      SECURITY DEFINER
      AS $function$
      DECLARE
        result jsonb;
      BEGIN
        EXECUTE sql;
        result := '{"success": true}'::jsonb;
        RETURN result;
      EXCEPTION
        WHEN OTHERS THEN
          result := jsonb_build_object(
            'success', false,
            'error', SQLERRM,
            'code', SQLSTATE
          );
          RETURN result;
      END;
      $function$;`
    }).catch(err => {
      // Function might already exist, continue
      console.log('Database init step 1 (create execute_sql function):', err?.message || 'Success');
    });

    // 2. Create function to enable realtime for tables
    await supabase.rpc('execute_sql', {
      sql: `
      CREATE OR REPLACE FUNCTION public.enable_realtime_for_table(table_name text)
      RETURNS boolean
      LANGUAGE plpgsql
      SECURITY DEFINER
      AS $function$
      BEGIN
        -- Set the replica identity to full for the specified table
        EXECUTE format('ALTER TABLE public.%I REPLICA IDENTITY FULL;', table_name);
        
        -- Check if the table is already added to the realtime publication
        IF NOT EXISTS (
          SELECT 1 FROM pg_publication_tables 
          WHERE pubname = 'supabase_realtime' 
          AND schemaname = 'public'
          AND tablename = table_name
        ) THEN
          -- Add the table to the realtime publication
          EXECUTE format('ALTER PUBLICATION supabase_realtime ADD TABLE public.%I;', table_name);
        END IF;
        
        RETURN true;
      END;
      $function$;`
    }).catch(err => {
      // Function might already exist, continue
      console.log('Database init step 2 (create enable_realtime function):', err?.message || 'Success');
    });
    
    console.log('Database initialization completed successfully');
  } catch (error) {
    console.error('Error initializing database structure:', error);
  }
};

// Call database initialization on client load
initializeDatabase().catch(console.error);

// Enable realtime for tables specifically related to cafes
export const enableRealtimeForTables = async () => {
  try {
    console.log("[Realtime] Starting enableRealtimeForTables");
    // We use a single channel with multiple table subscriptions for efficiency
    const tables = ['cafes', 'cafe_surveys', 'brand_sales'];
    
    // Enable realtime for each table via database function
    for (const table of tables) {
      try {
        const { data, error } = await supabase.rpc('enable_realtime_for_table', { 
          table_name: table 
        });
        
        if (error) {
          console.error(`[Realtime] Error enabling realtime via RPC for ${table}:`, error);
          
          // Fallback to edge function if RPC fails
          const { error: functionError } = await supabase.functions.invoke('enable-realtime', {
            body: { table_name: table }
          });
          
          if (functionError) {
            console.error(`[Realtime] Error enabling realtime via edge function for ${table}:`, functionError);
          } else {
            console.log(`[Realtime] Successfully enabled realtime via edge function for ${table}`);
          }
        } else {
          console.log(`[Realtime] Successfully enabled realtime via RPC for ${table}:`, data);
        }
      } catch (err) {
        console.error(`[Realtime] Failed to enable realtime for ${table}:`, err);
      }
    }
    
    // Create a more reliable monitoring channel
    const monitorChannel = supabase.channel('db-changes-monitor');
    
    // Add listeners for all tables
    tables.forEach(table => {
      // Listen for all changes (INSERT, UPDATE, DELETE)
      monitorChannel.on(
        'postgres_changes', 
        { 
          event: '*', 
          schema: 'public', 
          table 
        },
        (payload) => {
          console.log(`[Realtime] ${table} change detected:`, payload);
          
          // Notify via local storage for cross-tab communication
          localStorage.setItem('cafe_data_updated', String(new Date().getTime()));
          
          // Also dispatch a custom event for same-tab communication
          window.dispatchEvent(new CustomEvent('horeca_data_updated', {
            detail: { table, payload }
          }));
        }
      );
    });

    // Subscribe with retry logic
    const trySubscribe = async (attempt = 1, maxAttempts = 5) => {
      try {
        const status = monitorChannel.subscribe((status) => {
          console.log(`[Realtime] Subscription status: ${status}`);
        });
        console.log(`[Realtime] Monitor channel subscribed: ${status}`);
        return true;
      } catch (err) {
        console.error(`[Realtime] Subscription attempt ${attempt} failed:`, err);
        if (attempt < maxAttempts) {
          console.log(`[Realtime] Retrying in ${attempt * 2}s...`);
          await new Promise(resolve => setTimeout(resolve, attempt * 2000));
          return trySubscribe(attempt + 1, maxAttempts);
        }
        return false;
      }
    };
    
    await trySubscribe();
    console.log('[Realtime] Enabled for all database tables');
  } catch (error) {
    console.error('[Realtime] Error setting up realtime:', error);
  }
};

// Call the function when the client is initialized
enableRealtimeForTables();

// Force a data refresh
export const refreshCafeData = () => {
  console.log('[refreshCafeData] Triggering manual refresh');
  window.dispatchEvent(new CustomEvent('horeca_data_refresh_requested'));
  localStorage.setItem('cafe_data_updated', String(new Date().getTime()));
};
