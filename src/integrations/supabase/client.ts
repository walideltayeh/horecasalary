
// This file is automatically generated. Do not edit it directly.
import { createClient } from '@supabase/supabase-js';
import type { Database } from './types';

const SUPABASE_URL = "https://fxphpfvfcogalwtbishv.supabase.co";
const SUPABASE_PUBLISHABLE_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImZ4cGhwZnZmY29nYWx3dGJpc2h2Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDU0NTQyNDksImV4cCI6MjA2MTAzMDI0OX0.9sxvHMcbdX8n0VY_3sNF9qL7i5EN8FAMOHWy738reh0";

// Import the supabase client like this:
// import { supabase } from "@/integrations/supabase/client";

export const supabase = createClient<Database>(
  SUPABASE_URL, 
  SUPABASE_PUBLISHABLE_KEY,
  {
    auth: {
      autoRefreshToken: true,
      persistSession: true,
      detectSessionInUrl: true,
      storageKey: 'supabase-horeca-app-auth'
    },
    realtime: {
      params: {
        eventsPerSecond: 10
      }
    }
  }
);

// This function explicitly enables realtime for the tables we need
export const enableRealtimeForTables = async () => {
  try {
    // We use a single channel with multiple table subscriptions for efficiency
    const tables = ['cafes', 'cafe_surveys', 'brand_sales'];
    
    // Create a more reliable monitoring channel
    const monitorChannel = supabase.channel('db-changes-monitor');
    
    // Add listeners for all tables
    tables.forEach(table => {
      // Listen for inserts
      monitorChannel.on(
        'postgres_changes', 
        { 
          event: 'INSERT', 
          schema: 'public', 
          table 
        },
        (payload) => {
          console.log(`[Realtime] ${table} inserted:`, payload);
          // Notify via local storage for cross-tab communication
          localStorage.setItem('cafe_data_updated', String(new Date().getTime()));
        }
      );
      
      // Listen for updates
      monitorChannel.on(
        'postgres_changes', 
        { 
          event: 'UPDATE', 
          schema: 'public', 
          table 
        },
        (payload) => {
          console.log(`[Realtime] ${table} updated:`, payload);
          // Notify via local storage for cross-tab communication
          localStorage.setItem('cafe_data_updated', String(new Date().getTime()));
        }
      );
      
      // Listen for deletes
      monitorChannel.on(
        'postgres_changes', 
        { 
          event: 'DELETE', 
          schema: 'public', 
          table 
        },
        (payload) => {
          console.log(`[Realtime] ${table} deleted:`, payload);
          // Notify via local storage for cross-tab communication
          localStorage.setItem('cafe_data_updated', String(new Date().getTime()));
        }
      );
    });

    // Subscribe with retry logic
    const trySubscribe = async (attempt = 1, maxAttempts = 3) => {
      try {
        const status = await monitorChannel.subscribe((status) => {
          console.log(`[Realtime] Subscription status: ${status}`);
        });
        console.log(`[Realtime] Monitor channel subscribed: ${status}`);
        return true;
      } catch (err) {
        console.error(`[Realtime] Subscription attempt ${attempt} failed:`, err);
        if (attempt < maxAttempts) {
          console.log(`[Realtime] Retrying in ${attempt * 2}s...`);
          await new Promise(resolve => setTimeout(resolve, attempt * 2000));
          return trySubscribe(attempt + 1, maxAttempts);
        }
        return false;
      }
    };
    
    await trySubscribe();
    console.log('[Realtime] Enabled for all database tables');
  } catch (error) {
    console.error('[Realtime] Error setting up realtime:', error);
  }
};

// Call the function when the client is initialized
enableRealtimeForTables();
